## ì„¬ì˜ê°œìˆ˜ - dfs

[ë¬¸ì œë§í¬](https://www.acmicpc.net/problem/4963)

### ğŸ™ ë¬¸ì œ

ì •ì‚¬ê°í˜•ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆëŠ” ì„¬ê³¼ ë°”ë‹¤ ì§€ë„ê°€ ì£¼ì–´ì§„ë‹¤. ì„¬ì˜ ê°œìˆ˜ë¥¼ ì„¸ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/images/island.png)

í•œ ì •ì‚¬ê°í˜•ê³¼ ê°€ë¡œ, ì„¸ë¡œ ë˜ëŠ” ëŒ€ê°ì„ ìœ¼ë¡œ ì—°ê²°ë˜ì–´ ìˆëŠ” ì‚¬ê°í˜•ì€ ê±¸ì–´ê°ˆ ìˆ˜ ìˆëŠ” ì‚¬ê°í˜•ì´ë‹¤.

ë‘ ì •ì‚¬ê°í˜•ì´ ê°™ì€ ì„¬ì— ìˆìœ¼ë ¤ë©´, í•œ ì •ì‚¬ê°í˜•ì—ì„œ ë‹¤ë¥¸ ì •ì‚¬ê°í˜•ìœ¼ë¡œ ê±¸ì–´ì„œ ê°ˆ ìˆ˜ ìˆëŠ” ê²½ë¡œê°€ ìˆì–´ì•¼ í•œë‹¤. ì§€ë„ëŠ” ë°”ë‹¤ë¡œ ë‘˜ëŸ¬ì‹¸ì—¬ ìˆìœ¼ë©°, ì§€ë„ ë°–ìœ¼ë¡œ ë‚˜ê°ˆ ìˆ˜ ì—†ë‹¤.

### âŒ¨ï¸ ì…ë ¥

ì…ë ¥ì€ ì—¬ëŸ¬ ê°œì˜ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë¡œ ì´ë£¨ì–´ì ¸ ìˆë‹¤. ê° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì˜ ì²«ì§¸ ì¤„ì—ëŠ” ì§€ë„ì˜ ë„ˆë¹„ wì™€ ë†’ì´ hê°€ ì£¼ì–´ì§„ë‹¤. wì™€ hëŠ” 50ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ì€ ì–‘ì˜ ì •ìˆ˜ì´ë‹¤.

ë‘˜ì§¸ ì¤„ë¶€í„° hê°œ ì¤„ì—ëŠ” ì§€ë„ê°€ ì£¼ì–´ì§„ë‹¤. 1ì€ ë•…, 0ì€ ë°”ë‹¤ì´ë‹¤.

ì…ë ¥ì˜ ë§ˆì§€ë§‰ ì¤„ì—ëŠ” 0ì´ ë‘ ê°œ ì£¼ì–´ì§„ë‹¤.

### ğŸ¨ ì¶œë ¥

ê° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì— ëŒ€í•´ì„œ, ì„¬ì˜ ê°œìˆ˜ë¥¼ ì¶œë ¥í•œë‹¤.

### ğŸ’» ì œì¶œ ì½”ë“œ

```javascript
const fs = require("fs");
const filePath = process.platform === "linux" ? "/dev/stdin" : "./input.txt";
let input = fs.readFileSync(filePath).toString().trim().split("\n");
let currentLine = 0;

// ìš° í•˜ ì¢Œ ìƒ ëŒ€ê°ì„ *4
const position = [
  [1, 0],
  [0, 1],
  [-1, 0],
  [0, -1],
  [1, 1],
  [-1, 1],
  [-1, -1],
  [1, -1],
];

const isOverRange = ([x, y], [h, w]) => {
  if (x < 0 || y < 0 || x > h || y > w) return true;
  return false;
};

while (true) {
  // w : ì§€ë„ ë„“ì´ , h : ì§€ë„ ë†’ì´
  const [mapW, mapH] = input[currentLine].split(" ").map(Number);
  const [w, h] = [mapW - 1, mapH - 1];
  currentLine++;

  const map = [];
  for (let i = 0; i < mapH; i++) {
    const row = input[currentLine].split(" ").map(Number);
    map.push(row);
    currentLine++;
  }

  const visited = Array.from({ length: mapH }, () => Array(mapW).fill(false));
  const dfs = (x, y) => {
    if (visited[x][y]) return;
    visited[x][y] = true;
    if (!map[x][y]) return;
    for ([cx, cy] of position) {
      const [nx, ny] = [x + cx, y + cy];
      if (!isOverRange([nx, ny], [h, w])) {
        dfs(nx, ny);
      }
    }
  };

  let cnt = 0;
  for (let i = 0; i < mapH; i++) {
    for (let j = 0; j < mapW; j++) {
      if (visited[i][j] || !map[i][j]) continue;
      dfs(i, j);
      cnt++;
    }
  }

  if (mapW == 0 && mapH == 0) break;
  console.log(cnt);
}
```
